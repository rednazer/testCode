%define FLOAT_SIZE 0x04

;; Pull in the needed values for the current convolution
;; input_data start location, output_data write location
;; width of input data (number of rows or len(input_data)), # of output cols
;; need 4 regs
; r1 = input_data start location
; r2 = output_data write location
; r3 = width of input data
; r4 = # of output cols
imTwoColStrideOneTwoD:

	;; Set up loop y loop var
	lih r6, 0x00000		; init y loop var = 0
	lil r6, 0x00000

	;; For loop y_filter starts
	y_loop_start:

		lih r5, 0x00000		; init x loop var = 0
		lil r5, 0x00000

		;; For loop x_filter starts
		x_loop_start:
			;; Get input vector
			addi r25, r3, 0x05	; (the padded width) r25 = (r3 + 2 + 3) >> 2 << 2
			shri r25, r25, 0x02
			shli r25, r25, 0x02
			mul r25, r25, r6
			
			
			add r12, r25, r5
			shli r13, r12, 0x02		; r13 = r12 * FLOAT_SIZE same as r13 = r12 << 2 (a float is 0x4)
			add r14, r1, r13
			vldi 0b1111, v1, [r14+=0x00]
			; At this point v1 holds the input values
			; Take each value into floating point regs
			vindx r26, v1, 0x0
			vindx r27, v1, 0x1
			vindx r28, v1, 0x2
			vindx r29, v1, 0x3
			
			;; 2UP code start
				subi r20, r6, 0x02	; Check if y < 2 (to skip 2UP)
				blzi one_up_start
				write_output_elements(0x06, 0x02)	; Use to write vals to output

			one_up_start:
				;; 1UP code starts
				subi r20, r6, 0x01	; Check if y < 1 (to skip 1UP)
				blzi skip_2up
				addi r19, r3, 0x01	; Also check if y >= (width of input) - 1
				sub r20, r6, r19
				bgei zero_up_start
				write_output_elements(0x03, 0x01)	; Use to write vals to output

			zero_up_start:
				;; 0UP code starts
				addi r19, r3, 0x02	; Check if y >= (width of input) - 2
				sub r20, r6, r19
				bgei check_branch_conditionals
				write_output_elements(0x00, 0x00)	; Use to write vals to output

		check_branch_conditionals:
		;; Check loop conditionals
		; Branch to x_loop_start (check if r5 + 4 < width of input data)
		addi r5, r5, 0x04
		sub r20, r25, r5				; (padded width) - (r5 + 4) > 0
		bgzi x_loop_start	; Branch to start of x loop

	; Branch to y_loop_start (check if r6 + 1 == width of input data)
	addi r6, r6, 0x01
	sub r20, r3, r6
	bgzi y_loop_start	; branch to start of y loop


	;; If y loop not branched to, then im2col is done, so return here






; r1 = input_data start location
; r2 = output_data write location
; r3 = width of input data
; r25 = padded width of input
; r4 = # of output cols
; r5 = x loop var
; r6 = y loop var
; r26 = v1.0
; r27 = v1.1
; r28 = v1.2
; r29 = v1.3
; v1 = input_data values
;; For all data values:
; This will be the vector taken
; input_data[y][x] = r1 + (r6 * r3 + r5) * FLOAT_SIZE
; input_data[y][x] = r1 + (r6 * r25 + r5) * FLOAT_SIZE
; We then can index into the vector to see the 4 values (or fewer) pulled
;					START LOCATION + row offset + (x + y * (width of input data))
; output_data[row][col] = r2 + (col * r4) + ((r5 + offset) * FLOAT_SIZE + (r6 + offset) * FLOAR_SIZE * r3)
%macro write_output_elements(imm col_offset, imm y_offset)
	;; Setup a reg at the current column offset
	lih r10, 0x0000
	lil r10, col_offset
	;; 2 left
	; Skip if r5 == 0
		subi r20, r5, 0x00
		bezi .one_left
		addi r11, r10, 0x02
		write_output_location(r26, r11, -0x02, y_offset)

	.one_left:
		;; 1 left
		; Skip if r5 == 0 and if r5 + 1 >= r3
		subi r20, r5, 0x00
		bezi .zero_left
		addi r19, r5, 0x01
		subi r20, r19, r3
		bgei zero_left
		addi r11, r10, 0x01
		write_output_location(r26, r11, -0x01, y_offset)
		addi r11, r10, 0x02
		write_output_location(r27, r11, -0x01, y_offset)

	.zero_left:
		;; 0 left
		; Skip if r1 + 2 >= r3
		addi r19, r5, 0x02
		subi r20, r19, r3
		bgei zero_left
		addi r11, r10, 0x00
		write_output_location(r26, r11, 0x00, y_offset)
		addi r11, r10, 0x01
		write_output_location(r27, r11, 0x00, y_offset)
		addi r11, r10, 0x02
		write_output_location(r28, r11, 0x00, y_offset)

	.one_right:
		;; 1 right
		; Skip if r1 + 3 >= r3
		addi r19, r5, 0x03
		subi r20, r19, r3
		bgei zero_left
		addi r11, r10, 0x00
		write_output_location(r27, r11, 0x01, y_offset)
		addi r11, r10, 0x01
		write_output_location(r28, r11, 0x01, y_offset)
		addi r11, r10, 0x02
		write_output_location(r29, r11, 0x01, y_offset)

	.two_right:
		;; 2 right
		; Skip if r1 + 4 >= r3
		addi r19, r5, 0x04
		subi r20, r19, r3
		bgei zero_left
		addi r11, r10, 0x00
		write_output_location(r28, r11, 0x02, y_offset)
		addi r11, r10, 0x01
		write_output_location(r29, r11, 0x02, y_offset)
	
	.three_right:
		;; 3 right
		; Skip if r1 + 5 >= r3
		addi r19, r5, 0x05
		subi r20, r19, r3
		bgei zero_left
		addi r11, r10, 0x00
		write_output_location(r29, r11, 0x03, y_offset)

%endmacro

;; write_output_location performs a write to an output location based on given register and locations
;					START LOCATION + row offset + (x + y * (padded width of input data))
; output_data[row][col] = r2 + (col * r4) + ((r5 + x_offset) + (r6 - y_offset) * r25) * FLOAT_SIZE
; TODO: CHANGE (col * r4) TO ALSO MULTIPLY BY FLOAT_SIZE
%macro write_output_location(reg input_reg, reg column_index, imm x_offset, imm y_offset)
	mul r12, r4, column_index	; this is the column offset
	addi r13, r5, x_offset
	subi r14, r6, y_offset
	mul r14, r14, r25
	add r15, r13, r14
	shli r15, r15, 0x02			; this is the row offset
	add r16, r2, r12
	add r11, r16, r15			; this is the output location
	
	; Store to r11 with value of input reg
	st32 input_reg [r11+=0x00]
%endmacro


  r1: 0x000000004
  r2: 0x000000004
  r3: 0x000000004
  r4: 0x000000004
  r5: 0x000000007
  r6: 0x000000020




Where did you say to look for macro info?
	Is it possible to pass constants into macros? -> what would the format be (prolly not how I'm doing it)
I'm note sure how scoping works for labels. Are local labels within file? or how does it work?



