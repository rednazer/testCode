;; Information we need
; r1 = Input_matrix (also output of current)		- location 1
; r2 = Output location for padded matrix			- location 2
; r3 = Output location for im2col					- location 3
; r4 = Filter input location						- location 4
; r5 = width of matrix (x and y)
; r6 = depth of matrix (z) (number of filters)
;
depthwise_convolution_stride1:
	;; Pad matrix
	; r1 = Location 1 (input)
	; r2 = Location 2 (ouptut)
	; r3 = width (x and y length)
	; r4 = depth (z length)
	
	; Reorganizes Registers for Padding
	; r1 <= r1; r2 <= r2; r3 <= r5; r4 <= r6
	and r3, r5, r5
	and r4, r6, r6
	
	; pad the matrix
	push_stack_caller(padMatrix)
	
	;; For loop iterating through each z layer
	lih r9, 0x0000
	lil r9, 0x0000		; Z loop var
	
	layer_loop:
		;; im2col (stride 2 2d)
		; r1 = Location 2 + ( ((width+2+3)>>2<<2) * (width+2) * (curr depth) * FLOAT_SIZE)
		; r2 = Location 3 + ( ((width+2)^2+3)>>2<<4 * 9 * (curr depth) ;FloatSizeBakedInto<<4) (output)
		; r3 = width (x and y) - pad matrix (width + 2)
		; r4 = num im2col columns (per row)- this is calculated from width (width - 2 + 2)
		peek_stack()
		addi r12, r5, 0x05
		shri r12, r12, 0x02
		shli r12, r12, 0x02
		addi r13, r5, 0x02
		mul r12, r12, r13
		mul r12, r12, r9
		shli r12, r12, 0x02			; r1 offset
		
		mul r13, r13, r13
		addi r13, r13, 0x03
		shri r13, r13, 0x02
		shli r13, r13, 0x04
		lih r14, 0x00
		lil r14, 0x09
		mul r13, r13, r14
		mul r13, r13, r9			; r2 offset
		
		add r1, r2, r12
		add r2, r3, r13
		addi r3, r5, 0x02
		addi r4, r5, 0x00
		
		; CALL IM2COL
		
		
		;; MatMul
		; r1 = Location 4 + 12 * (curr depth) * FLOAT_SIZE (Input)
		; r2 = Location 3 + ( ((width+2)^2+3)>>2<<4 * 9 * (curr depth) ;FloatSizeBakedInto<<4) (input)
		; r3 = Location 1 + (width)^2 * (curr depth) * FLOAT_SIZE (Output)
		; r4 = width of matrix - common length (3x3 for filter size)
		; r5 = # cols for r1 (A matrix) - number of filters
		; r6 = # rows in r2 (B matrix) - number of im2col columns
		peek_stack()
		lih r12, 0x00
		lil r12, 0x0c
		mul r12, r12, r9
		shli r12, r12, 0x02			; r1 offset
		
		addi r13, r5, 0x02
		mul r13, r13, r13
		addi r13, r13, 0x03
		shri r13, r13, 0x02
		shli r13, r13, 0x02			; r6
		shli r14, r13, 0x02
		lih r16, 0x00
		lil r16, 0x09
		mul r14, r14, r16
		mul r14, r14, r9			; r2 offset
		
		mul r15, r5, r5
		mul r15, r15, r9
		shli r15, r15, 0x02			; r3 offset
		
		add r1, r4, r12
		add r2, r3, r14
		add r1, r1, r15
		addi r4, r16, 0x00
		lih r5, 0x00
		lil r5, 0x01		; r5 = 1 because depthwise
		addi r6, r13, 0x00
		
		; CALL MATMUL
		
	;; Check loop condition
	; branch if r9 < r6 (r9-r6<0)
	addi r9, r9, 0x01
	sub r20, r9, r6
	blzi layer_loop
	
	; Return to caller function
	jmpr r31, 0x00

